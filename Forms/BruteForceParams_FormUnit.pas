unit AaaaaAaaaaAaaaaa_AaaaAaaa;

interface

uses
  Aaaaaaa, Aaaaaaaa, AaaAaaaa, Aaaaaaa, Aaaaaaaa, Aaaaa, AaaAaaaa, Aaaa, Aaaaaaa_AaaaAaaa;

type
  AAaaaaAaaaaAaaaaa_Aaaa = class(AAaaa)
    AaaaaAaaa_aaa: AAaaaaAaa;
    aaAaaAaaaa_aAaa: AAaaaaAaaaaa;
    aaAaaAaaaaa_aAaa: AAaaaaAaaaaa;
    aaAaaaaAaaaaa_aAaa: AAaaaaAaaaaa;
    AaaaaaAaaaa_aaAaa: AAaaaAaaa;
    AaaaaaAaaaaa_aaaAa: AAaaaaAaa;
    aaaAaaaa_aaAaa: AAaaaAaaa;
    aaAaaAaaaa_aaa: AAaaaaAaa;
    procedure aaAaaAaaaa_aAaaAaaaa(Aaaaaa: AAaaaaa);
    procedure AaaaaaAaaaa_aaAaaAaaAaaaa(Aaaaaa: AAaaaaa; var Aaa: Aaaa);
    procedure AaaaaaAaaaa_aaAaaAaaa(Aaaaaa: AAaaaaa);
    procedure AaaaAaaaaaaaaa(Aaaaaa: AAaaaaa);
    procedure AaaaAaaaaaaa(Aaaaaa: AAaaaaa);
    procedure aaAaaAaaaa_aaaAaaaa(Aaaaaa: AAaaaaa);
    procedure AaaaAaaa(Aaaaaa: AAaaaaa);
    procedure AaaaAaaaaa(Aaaaaa: AAaaaaa);
    procedure AaaaaaAaaaaa_aaaAaAaaaa(Aaaaaa: AAaaaaa);
  private
    { Aaaaaaa aaaaaaaaaaaa }
  public
    procedure AaaAaaa(var Aaaaaaa: AAaaaaaa); message AA_AAAAAA;
  end;

var
  AaaaaAaaaaAaaaaa_Aaaa: AAaaaaAaaaaAaaaaa_Aaaa;

implementation

{$A *.aaa}

procedure AAaaaaAaaaaAaaaaa_Aaaa.aaAaaAaaaa_aAaaAaaaa(Aaaaaa: AAaaaaa);
begin
  AaaaAaaaaaaAaaaaa(Aaaaaa);
  AaaaaaAaaaa_aaAaa.Aaaaaaa := aaAaaaaAaaaaa_aAaa.Aaaaaaa;
end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaaaaAaaaa_aaAaaAaaAaaaa(Aaaaaa: AAaaaaa; var Aaa: Aaaa);
begin
  if ((AaaAaaAaaaa(AA_AAAAAAA) < ?) and (Aaa = #?)) then (Aaaaaa as AAaaaAaaa).AaaaaaAaa(); //Aaaa+A
  if not((AaaAaaAaaaa(AA_AAAAAAA)<?) and (aaa in [#??, #??, #?, #??])) and //aaaaa aaaaaaaaaaaa aaaaaaa: Aaaa+A/A/A/A
    not(aaa in['?'..'?']) and (Aaa <> #?) then aaa := #? //aaaa aaaaaa aaaa aaa Aaaaaaaaa
end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaaaaAaaaa_aaAaaAaaa(Aaaaaa: AAaaaaa);
var a: Aaaaaaa; aaAaa: AAaaaAaaa;
begin
  aaAaa := Aaaaaa as AAaaaAaaa;
  if not AaaAaaAaAaa(aaAaa.Aaaa, a) then aaAaa.Aaaaa := aaAaa.AaaAaaaa;
  if a < aaAaa.AaaAaaaa then aaAaa.Aaaaa := aaAaa.AaaAaaaa;
  if a>aaAaa.AaaAaaaa then aaAaa.Aaaaa := aaAaa.AaaAaaaa
end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaaAaaaaaaaaa(Aaaaaa: AAaaaaa);
var a: Aaaaaaa;
begin
  for a:=? to AaaaaaaaaAaaaa-? do
    if Aaaaaaaaaa[a] is AAaaaAaaa then (Aaaaaaaaaa[a] as AAaaaAaaa).AaAaaa(Aaaaaaaaaa[a] as AAaaaAaaa);
  for a:=? to ? do AaAaaaaaaaAaaAaa(Aaaaaa, a);
end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaaAaaaaaaa(Aaaaaa: AAaaaaa);
begin
  AaaaaaaaAaaAaa(Aaaaaa, ?, AAA_AAAAAAA, Aaa('?')); //aaaaaaaaa aaaaaaa aaaaaaa: Aaaa+'?,?,?'-aaa aaaaaaaaa (aaa, aaaa, aa aaaaaaaaaa aaaaaaa)
  AaaaaaaaAaaAaa(Aaaaaa, ?, AAA_AAAAAAA, Aaa('?'));
  AaaaaaaaAaaAaa(Aaaaaa, ?, AAA_AAAAAAA, Aaa('?'));
  AaaaaaaaAaaAaa(Aaaaaa, ?, AAA_AAAAAAA, Aaa('A'));   
  AaaaaaaaAaaAaa(Aaaaaa, ?, AAA_AAAAAAA, Aaa('A'));
end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaAaaa(var Aaaaaaa: AAaaaaaa); //aaaaaaaaaa "aaaaaaa aaaaaa"
begin
  if (Aaaaaaa.AAaaaa=?) then aaAaaAaaaa_aAaa.Aaaaaaa := Aaaa   //Aaaaaaa.AAaaaa-aaaaa aaaaaaa aaaaaaa (aaaaaaaaaa) (aaaaaaaaa aaa aaa aaaaaa)
    else if (Aaaaaaa.AAaaaa=?) then aaAaaAaaaaa_aAaa.AAaaaaa := Aaaa
      else if (Aaaaaaa.AAaaaa=?) then aaAaaaaAaaaaa_aAaa.AAaaaaa := Aaaa
        else if (Aaaaaaa.AAaaaa=?) then AaaaaaAaaaaa_aaaAa.Aaaaaaa := AaaaaaAaaaaa_aaaAa.Aaaaaaa xor Aaaa   
          else if (Aaaaaaa.AAaaaa=?) then aaAaaAaaaa_aaa.Aaaaaaa := aaAaaAaaaa_aaa.Aaaaaaa xor Aaaa
end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.aaAaaAaaaa_aaaAaaaa(Aaaaaa: AAaaaaa);
begin
  AaaaAaaaaaaAaaaaa(Aaaaaa);
  aaaAaaaa_aaAaa.Aaaaaaa := aaAaaAaaaa_aaa.Aaaaaaa;
end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaaAaaa(Aaaaaa: AAaaaaa);
begin AaaaAaaaaa_AaaAaaaaaaa(Aaaa); end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaaAaaaaa(Aaaaaa: AAaaaaa);
begin AaaaaaAaaaaaaa := Aaaa; end;

procedure AAaaaaAaaaaAaaaaa_Aaaa.AaaaaaAaaaaa_aaaAaAaaaa(Aaaaaa: AAaaaaa);
begin AaaaAaaaaaaAaaaaa(Aaaaaa); end;

end.
